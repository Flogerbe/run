<%

max_points=200
scale_factor=1

series={}
series[:elevation]={
	input: JSON::parse(@activity.elevation_series).map{|e| e.round(2) if e},
	color: '#666666',
	name: "Elevation",
	unit: "metres"
} if @activity.elevation_series
series[:hr]={
	input: JSON::parse(@activity.hr_series),
	color: '#dd2222',
	name: "Heart rate",
	unit: "bpm"
} if @activity.hr_series

distance_series=JSON::parse(@activity.distance_series).map{|d| d.to_i if d} if @activity.distance_series

time_series=JSON::parse(@activity.time_series).map{ |d| DateTime.parse(d).strftime("%Q").to_i }	

if distance_series
	x_axis=distance_series
else
	x_axis=time_series
end

scale_factor=[x_axis.count/max_points,1].max.to_i

# Join each input up to the time_series array using zip to get our plottable array
# but only when the item itself isn't nil
series.each_value do |spec|
	spec[:graph]=x_axis.zip(spec[:input]).select.with_index{|item,index| index%scale_factor==0 && item[0] && item[1]}
end

%>
jQuery('#graph_<%= @activity.id %>').highcharts({
	chart: {
		type: 'area'
	},
	title: {
		text: null
	},
	plotOptions: {
		series: {
			marker: {
				radius: 1
			}
		}
	},
	colors: <%= series.map{ |k,v| v[:color]}.to_json.html_safe %>
	,
	xAxis: {
		<% if distance_series %>
		type: 'linear',
		title: {
			text: 'Distance'
		}
		<% else %>
		type: 'datetime',
		title: {
			text: 'Time'
		}
		<% end %>
	},
	yAxis: [<% series.each_value.with_index do |s,i| %><%= ", " if i>0 %>{
		title: {
			text: '<%= s[:unit] %>'
		},
		min: <%= "#{s[:input].select{|i| i}.min*0.9}" %>,
		max: <%= "#{s[:input].select{|i| i}.max*1.1}" %>
		<%= ", opposite: true" if i.odd? %>
	}<% end %>
	],
	series: [<% series.each_value.with_index do |s,i| %><%= ',' if i>0 %>{
		yAxis: <%= i %>,
		name: '<%= s[:name] %>',
		data: <%= s[:graph] %>
	}
	<%end%>
	]
});
